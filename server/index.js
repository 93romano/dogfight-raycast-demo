// server/index.js

import { createServer } from 'http';
import { WebSocketServer } from 'ws';
import { Buffer } from 'buffer';

const httpServer = createServer();
const wss = new WebSocketServer({ server: httpServer });

// Game state
const players = new Map();
const gameState = {
  lastUpdate: Date.now(),
  tickRate: 60,
  tickInterval: 1000 / 60,
  lastLogTime: null
};

// Binary protocol constants
const PACKET_TYPES = {
  STATE_UPDATE: 0x01,
  PLAYER_JOINED: 0x02,
  PLAYER_LEFT: 0x03,
  INPUT: 0x04
};

// Packet header size
const HEADER_SIZE = 8;

// Player state size
const PLAYER_STATE_SIZE = 46; // 2 + 12 + 16 + 12 + 4 bytes

function createStateUpdateBuffer(players) {
  const buffer = Buffer.alloc(HEADER_SIZE + (players.size * PLAYER_STATE_SIZE));
  let offset = HEADER_SIZE;
  
  // Write header
  buffer.writeUInt16BE(0, 0); // Sequence number
  buffer.writeUInt8(PACKET_TYPES.STATE_UPDATE, 2);
  buffer.writeUInt32BE(Date.now() % 0xFFFFFFFF, 3); // 32ÎπÑÌä∏ Î≤îÏúÑÎ°ú Ï†úÌïú
  buffer.writeUInt8(0, 7); // Flags
  
  // Write player states
  for (const [id, player] of players) {
    buffer.writeUInt16BE(id, offset);
    offset += 2;
    
    // Position (3x float32)
    buffer.writeFloatBE(player.position[0], offset);
    buffer.writeFloatBE(player.position[1], offset + 4);
    buffer.writeFloatBE(player.position[2], offset + 8);
    offset += 12;
    
    // Rotation (4x float32)
    buffer.writeFloatBE(player.rotation[0], offset);
    buffer.writeFloatBE(player.rotation[1], offset + 4);
    buffer.writeFloatBE(player.rotation[2], offset + 8);
    buffer.writeFloatBE(player.rotation[3], offset + 12);
    offset += 16;
    
    // Velocity (3x float32)
    buffer.writeFloatBE(player.velocity[0], offset);
    buffer.writeFloatBE(player.velocity[1], offset + 4);
    buffer.writeFloatBE(player.velocity[2], offset + 8);
    offset += 12;
    
    // Input state (4 bytes)
    buffer.writeUInt32BE(player.inputState, offset);
    offset += 4;
  }
  
  return buffer;
}

// ÏõÄÏßÅÏûÑ Ïù¥Î≤§Ìä∏ Ï≤òÎ¶¨ Ìï®Ïàò Í∞úÏÑ†
function handleMovementEvent(playerId, event, ws) {
  const player = players.get(playerId);
  if (!player) {
    console.log(`‚ö†Ô∏è Player ${playerId} not found for movement event`);
    return;
  }

  console.log(`üéÆ Player ${playerId} movement:`, event.input);

  // ÏûÖÎ†• ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
  player.inputState = {
    forward: event.input.forward,
    backward: event.input.backward,
    left: event.input.left,
    right: event.input.right,
    up: event.input.up,
    down: event.input.down,
    roll: event.input.roll
  };

  // ÏúÑÏπòÏôÄ ÌöåÏ†Ñ ÏóÖÎç∞Ïù¥Ìä∏
  player.position = event.position;
  player.rotation = event.rotation;
  player.speed = event.speed;

  // Îã§Î•∏ ÌîåÎ†àÏù¥Ïñ¥Îì§ÏóêÍ≤å ÏõÄÏßÅÏûÑ Ïù¥Î≤§Ìä∏ Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏
  const movementMessage = JSON.stringify({
    type: 'player-movement',
    playerId: playerId,
    event: event
  });

  let broadcastCount = 0;
  wss.clients.forEach(client => {
    if (client.readyState === WebSocket.OPEN && client !== ws) {
      client.send(movementMessage);
      broadcastCount++;
    }
  });

  console.log(`üì° Broadcasted movement to ${broadcastCount} other players`);

  // ÏõÄÏßÅÏûÑ ÌôïÏù∏ ÏùëÎãµ
  ws.send(JSON.stringify({
    type: 'movement-ack',
    timestamp: Date.now()
  }));
}

wss.on('connection', (ws, req) => {
  console.log('ÔøΩÔøΩ New connection');
  
  // ÏøºÎ¶¨ ÌååÎùºÎØ∏ÌÑ∞ÏóêÏÑú ÏÇ¨Ïö©ÏûêÍ∞Ä ÏûÖÎ†•Ìïú Player ID Ï∂îÏ∂ú
  const url = new URL(req.url, 'http://localhost');
  const requestedPlayerId = parseInt(url.searchParams.get('playerId'));
  
  let playerId;
  
  // ÏÇ¨Ïö©ÏûêÍ∞Ä ÏöîÏ≤≠Ìïú IDÍ∞Ä Ïú†Ìö®ÌïúÏßÄ ÌôïÏù∏
  if (requestedPlayerId && requestedPlayerId >= 1 && requestedPlayerId <= 9999) {
    // ID Ï∂©Îèå Ï≤¥ÌÅ¨
    if (players.has(requestedPlayerId)) {
      // Ï∂©Îèå Ïãú ÏóêÎü¨ Î©îÏãúÏßÄ Ï†ÑÏÜ°
      ws.send(JSON.stringify({
        type: 'player-id-conflict',
        message: `Player ID ${requestedPlayerId} is already in use`
      }));
      ws.close(1000, 'Player ID conflict');
      return;
    }
    
    playerId = requestedPlayerId;
    console.log(`üéØ User requested Player ID: ${playerId}`);
  } else {
    // Ïú†Ìö®ÌïòÏßÄ ÏïäÏùÄ ID ÏöîÏ≤≠ Ïãú ÏóêÎü¨
    ws.send(JSON.stringify({
      type: 'player-id-conflict',
      message: 'Invalid Player ID. Must be between 1-9999.'
    }));
    ws.close(1000, 'Invalid Player ID');
    return;
  }
  
  // WebSocket Í∞ùÏ≤¥Ïóê Ï†ïÎ≥¥ Ï†ÄÏû•
  ws.playerId = playerId;
  
  // ÌîåÎ†àÏù¥Ïñ¥ ÏÉÅÌÉú ÏÉùÏÑ±
  players.set(playerId, {
    position: [0, 0, 0],
    rotation: [0, 0, 0, 1],
    velocity: [0, 0, 0],
    inputState: {
      forward: false,
      backward: false,
      left: false,
      right: false,
      up: false,
      down: false,
      roll: 0
    },
    speed: 0,
    lastInputSequence: 0,
    lastActivity: Date.now(),
    lastPingLog: null,
    lastPositionLog: null,
    lastBroadcastLog: null,
    lastMovementLog: null
  });
  
  // Send initial state
  ws.send(createStateUpdateBuffer(players));

  // Send welcome message
  ws.send(JSON.stringify({
    type: 'welcome',
    playerId: playerId
  }));
  
  // Îã§Î•∏ ÌîåÎ†àÏù¥Ïñ¥Îì§ÏóêÍ≤å ÏÉà ÌîåÎ†àÏù¥Ïñ¥ Ï∞∏Í∞Ä ÏïåÎ¶º
  const joinMessage = JSON.stringify({
    type: 'player-joined',
    id: playerId.toString(),
    state: players.get(playerId)
  });
  
  wss.clients.forEach(client => {
    if (client.readyState === WebSocket.OPEN && client !== ws) {
      client.send(joinMessage);
    }
  });
  
  ws.on('message', (data) => {
    // ÌôúÎèô ÏãúÍ∞Ñ ÏóÖÎç∞Ïù¥Ìä∏
    const now = Date.now();
    const player = players.get(playerId);
    if (player) {
      player.lastActivity = now;
    }
    
    try {
      // Keep-alive Ï≤òÎ¶¨
      if (typeof data === 'string' && data === 'ping') {
        ws.send('pong');
        return;
      }

      // JSON Î©îÏãúÏßÄ Ï≤òÎ¶¨
      if (typeof data === 'string') {
        const message = JSON.parse(data);
        
        switch (message.type) {
          case 'update':
            const updatePlayerId = message.playerId || playerId;
            const player = players.get(updatePlayerId);
            if (player) {
              // ÏúÑÏπò ÏóÖÎç∞Ïù¥Ìä∏ Î°úÍ∑∏ Ï§ÑÏûÑ - 5Ï¥àÎßàÎã§Îßå
              if (!player.lastPositionLog || now - player.lastPositionLog > 5000) {
                console.log(`üîÑ Updating player ${updatePlayerId} position:`, message.state.position);
                player.lastPositionLog = now;
              }
              
              // ÌîåÎ†àÏù¥Ïñ¥ ÏÉÅÌÉú ÏóÖÎç∞Ïù¥Ìä∏
              player.position = message.state.position;
              player.rotation = message.state.rotation;
              
              // ÌïòÏù¥Î∏åÎ¶¨Îìú: JSONÏùÑ Î∞îÏù¥ÎÑàÎ¶¨Î°ú Î≥ÄÌôòÌï¥ÏÑú Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏
              const binaryUpdate = createPlayerUpdateBuffer(updatePlayerId, message.state);
              
              let broadcastCount = 0;
              wss.clients.forEach(client => {
                if (client.readyState === WebSocket.OPEN && client !== ws) {
                  client.send(binaryUpdate);
                  broadcastCount++;
                }
              });
              
              if (broadcastCount > 0) {
                console.log(`üì° Broadcasted binary position update to ${broadcastCount} other players`);
              }
            }
            break;
          case 'movement':
            // ÏõÄÏßÅÏûÑ Ïù¥Î≤§Ìä∏Îäî JSONÏúºÎ°ú Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏ (Íµ¨Ï°∞ÌôîÎêú Îç∞Ïù¥ÌÑ∞)
            const eventPlayerId = message.playerId || playerId;
            const movementMessage = JSON.stringify({
              type: 'player-movement',
              playerId: eventPlayerId,
              event: message.event
            });
            
            let movementBroadcastCount = 0;
            wss.clients.forEach(client => {
              if (client.readyState === WebSocket.OPEN && client !== ws) {
                client.send(movementMessage);
                movementBroadcastCount++;
              }
            });
            
            if (movementBroadcastCount > 0) {
              console.log(`üì° Broadcasted movement event to ${movementBroadcastCount} other players`);
            }
            break;
          default:
            console.log('Unknown message type:', message.type);
        }
      } else if (data instanceof Buffer) {
        // Í∏∞Ï°¥ Î∞îÏù¥ÎÑàÎ¶¨ Ï≤òÎ¶¨ Î°úÏßÅ Ïú†ÏßÄ
        console.log(`üì¶ Binary data received from player ${playerId}, length:`, data.length);
        
        let broadcastCount = 0;
        wss.clients.forEach(client => {
          if (client.readyState === WebSocket.OPEN && client !== ws) {
            client.send(data);
            broadcastCount++;
          }
        });
        
        if (broadcastCount > 0) {
          console.log(`üì° Broadcasted binary data to ${broadcastCount} other players`);
        }
      } else {
        console.log(`‚ùì Unknown data type from player ${playerId}:`, typeof data);
      }
    } catch (error) {
      console.error('Error processing message:', error);
    }
  });
  
  ws.on('close', (code, reason) => {
    console.log(`üîå Connection closed for player ${playerId}. Code: ${code}, Reason: ${reason}`);
    
    // ÌîåÎ†àÏù¥Ïñ¥ Ï†úÍ±∞
    players.delete(playerId);
    
    // Îã§Î•∏ ÌÅ¥ÎùºÏù¥Ïñ∏Ìä∏ÏóêÍ≤å ÏïåÎ¶º
    const leaveMessage = JSON.stringify({
      type: 'player-left',
      playerId: playerId
    });
    
    wss.clients.forEach(client => {
      if (client.readyState === WebSocket.OPEN) {
        client.send(leaveMessage);
      }
    });
  });

  ws.on('error', (error) => {
    console.error(`WebSocket error for player ${playerId}:`, error);
  });
});

// Ïó∞Í≤∞ ÏÉÅÌÉú Î™®ÎãàÌÑ∞ÎßÅ (ÏÑ†ÌÉùÏÇ¨Ìï≠)
setInterval(() => {
  const now = Date.now();
  const inactiveThreshold = 5 * 60 * 1000; // 5Î∂Ñ
  
  for (const [id, player] of players) {
    if (now - player.lastActivity > inactiveThreshold) {
      console.log(`‚è∞ Player ${id} inactive for ${Math.floor((now - player.lastActivity) / 1000)}s`);
      // Ïó¨Í∏∞ÏÑúÎäî Ïó∞Í≤∞ÏùÑ ÎÅäÏßÄ ÏïäÍ≥† Î°úÍ∑∏Îßå ÎÇ®ÍπÄ
    }
  }
}, 60000); // 1Î∂ÑÎßàÎã§ Ï≤¥ÌÅ¨

// Game loop Í∞úÏÑ† - Î°úÍ∑∏ ÎπàÎèÑ Ï§ÑÏûÑ
setInterval(() => {
  const now = Date.now();
  if (now - gameState.lastUpdate >= gameState.tickInterval) {
    gameState.lastUpdate = now;
    
    // Î™®Îì† ÌîåÎ†àÏù¥Ïñ¥ ÏÉÅÌÉúÎ•º Î∞îÏù¥ÎÑàÎ¶¨Î°ú Î∏åÎ°úÎìúÏ∫êÏä§Ìä∏
    const stateBuffer = createStateUpdateBuffer(players);
    let broadcastCount = 0;
    
    wss.clients.forEach(client => {
      if (client.readyState === WebSocket.OPEN) {
        client.send(stateBuffer);
        broadcastCount++;
      }
    });
    
    // Î°úÍ∑∏ ÎπàÎèÑ Ï§ÑÏûÑ - 10Ï¥àÎßàÎã§Îßå Ï∂úÎ†•
    if (broadcastCount > 0 && players.size > 0) {
      if (!gameState.lastLogTime || now - gameState.lastLogTime > 10000) {
        console.log(`üì° Broadcasted state to ${broadcastCount} clients (${players.size} players)`);
        gameState.lastLogTime = now;
      }
    }
  }
}, 1);

// ÏÉàÎ°úÏö¥ Ìï®Ïàò: Í∞úÎ≥Ñ ÌîåÎ†àÏù¥Ïñ¥ ÏóÖÎç∞Ïù¥Ìä∏Î•º Î∞îÏù¥ÎÑàÎ¶¨Î°ú Î≥ÄÌôò
function createPlayerUpdateBuffer(playerId, state) {
  const buffer = Buffer.alloc(HEADER_SIZE + PLAYER_STATE_SIZE);
  let offset = HEADER_SIZE;
  
  // Write header
  buffer.writeUInt16BE(0, 0); // Sequence number
  buffer.writeUInt8(PACKET_TYPES.STATE_UPDATE, 2); // Packet type
  buffer.writeUInt32BE(Date.now(), 3); // Timestamp
  buffer.writeUInt8(0, 7); // Flags
  
  // Write player ID
  buffer.writeUInt16BE(parseInt(playerId), offset);
  offset += 2;
  
  // Write position (3x float32)
  buffer.writeFloatBE(state.position[0], offset);
  buffer.writeFloatBE(state.position[1], offset + 4);
  buffer.writeFloatBE(state.position[2], offset + 8);
  offset += 12;
  
  // Write rotation (4x float32)
  buffer.writeFloatBE(state.rotation[0], offset);
  buffer.writeFloatBE(state.rotation[1], offset + 4);
  buffer.writeFloatBE(state.rotation[2], offset + 8);
  buffer.writeFloatBE(state.rotation[3], offset + 12);
  offset += 16;
  
  // Write velocity (3x float32) - zeros
  buffer.writeFloatBE(0, offset);
  buffer.writeFloatBE(0, offset + 4);
  buffer.writeFloatBE(0, offset + 8);
  offset += 12;
  
  // Write input state (4 bytes) - zeros
  buffer.writeUInt32BE(0, offset);
  
  return buffer;
}

httpServer.listen(3000, () => {
  console.log('üöÄ Zero-lag FPS server running on http://localhost:3000');
});
